\section{Domain Specific Modeling}

One of the important problems in game development is the consequent task execution problem. The necessity of doing one task at a time often makes it inefficient to create big developer teams. The example of such problematic workflow is provided in \textbf{Example  \ref{FirstGameEx}}.

\begin{example}
\label{FirstGameEx}
   Five people decided to develop an RPG game. The development started in June 2014. The storyline designer generated the concept of the game till the end of July 2014. Design and implementation of the logical core was made by the end  of August 2014. Meanwhile, the level designer decided what kind of assets one might need and requested from the artist to prepare them. At the beginning of September 2014 the logical core was completed. Nevertheless, there were no ready assets for the level designer to carry out one's part. Till the end of the month most of the assets were ready, so the level designer finally had a work to do. When the autumn ended, level design was almost completed. The storyline designer began filling the game world with available characters and narratives. In January 2015 the alpha version of the game was created, but after extensive testing several bugs were found. That's why 1 more month was spent on updating the logical core of the game. Overall duration of the game development process was 9 month.
\end{example}\par
 During the particular moment of the time, there were a few people on the development team that had a work to do.
 One way to solve this problem is to make use of general-purpose modeling languages.
 The most popular example is probably UML. Due to this languages the new approach became available. The situation from the first example now could be solved as in the following one.
\begin{example}\par
     Let us imagine the similar situation to the previous example.
      The development started in June 2015. The storyline designer generated the concept of the game till the end of July 2015. The model of the game was created in the first part of August. The resulting model dictated that there is an arcade game logical core to be written, a forest to be created by the artist and the story to be told. Second part of the month was spent on refining that model. The interfaces and internal structure of the logical core of the game were specified. The artist created several forest low-poly assets and the storyline designer made some example narratives featuring the forest. Since the logical core was specified, the artist could already start designing the protagonist. The level designer got all the information to prepare some informal level templates. Two weeks later the final details were embedded into the model. The input format for levels and assets was approved and the first sample backbone storyline created. During the next month the logical core was finished, all low-poly assets were made, and the storyline was extended. The level designer who used to operate with abstract assets created several basic game levels. Next month was spent on testing, detailing assets, narratives implementation. One more month for error handling and improving the overall game experience. After less than seven month the game was ready.
\end{example}
The main advantage of such approach is that, besides the increased amount of work made by each developer, the overall time of development is significantly decreased. In this example the model that was made on the first stages of the development served only the specification role. In some cases, with the help of code generators and other similar software, it is possible for the model to be interpreted into the final result automatically.
One of the main drawbacks is that there are usually large parts of the development life cycle when developers are deprived of integration testing.
The extreme example of such approach is DSM (Domain Specific Modeling) that is explained in \cite{DUMMY:7}. The idea is to create the domain-specific modeling language, describe the future application in terms of these language and then convert this specification to the actual product (applicable not only to code) by using code generators and similar software that is either created earlier during the development process or reused by adjusting the configuration of already existing software. This approach requires a lot of work to be done on the first stage of development, but can simplify all other parts of the development life cycle.
Among other, domain specific modeling is a great example of how people are willing to sacrifice their time to achieve the greater comfort in the future. 